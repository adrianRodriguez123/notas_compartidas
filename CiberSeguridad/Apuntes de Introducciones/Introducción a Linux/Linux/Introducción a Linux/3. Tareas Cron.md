## 12. Privilegios especiales – Capabilities

https://gtfobins.github.io/

Si tenemos *[[Capabilites]]*, podemos escalar permisos.

[[getcap]]
Listar las *Capabilites* del sistema.

`getcap -r / 2>/dev/null`
Hacemos un `getcap` de manera recursiva, desde la raíz del sistema, y ocultando los *Stderr*, ya que, como usuarios normales (Alfonso, S4vitar) hay rutas a las que no tenemos acceso.

Para añadir una *Capability (el de python)*, como *root*:
`setcap cap_setuid+ep /usr/bin/python3.9`

`setcap -r /usr/bin/python3.9`
Para quitarle la *Capability* de controlar la *uid*.

## 13. Estructura de directorios del sistema

Los más importantes son:

-   BIN
-   BOOT
-   DEV
-   ETC
-   HOME
-   LIB
-   MEDIA
-   OPT
-   PROC
-   ROOT
-   SBIN
-   SRV
-   SYS
-   TMP
-   USR
-   VAR

### Directorio [[Raíz]]

El directorio raíz, simbolizado por el símbolo (/), es el **directorio principal a partir del cual se ramifican todo el resto de directorios**.

### Directorio [[/bin]]

El directorio /bin es un **directorio estático y compartible en el que se almacenan archivos binarios/ejecutables necesarios para el funcionamiento del sistema**. Estos archivos binarios los pueden usar la totalidad de usuarios del sistema operativo.

### Directorio [[/boot]]

Es un directorio estático no compartible que **contiene la totalidad de archivos necesarios para el arranque del ordenador excepto los archivos de configuración**. Algunos de los archivos indispensables para el arranque del sistema que acostumbra a almacenar el directorio /boot son el kernel y el gestor de arranque Grub.

### Directorio [[/dev]]

El sistema operativo Gnu-Linux trata los dispositivos de hardware como si fueran un archivo. **Estos archivos que representan nuestros dispositivos de hardware se hallan almacenados en el directorio /dev**.

Algunos de los archivos básicos que podemos encontrar en este directorio son:

-   **cdrom** que representa nuestro dispositivo de CDROM.
-   **sda** que representa nuestro disco duro sata.
-   **audio** que representa nuestra tarjeta de sonido.
-   **psaux** que representa el puerto PS/2.
-   **lpx** que representa nuestra impresora.
-   **fd0** que representa nuestra disquetera.

### Directorio [/etc]

El directorio /etc es un **directorio estático que contiene los archivos de configuración del sistema operativo**. Este directorio también contiene archivos de configuración para controlar el funcionamiento de diversos programas.

Algunos de los archivos de configuración de la carpeta /etc pueden ser sustituidos o complementados por archivos de configuración ubicados en nuestra carpeta personal /home.

### Directorio [[/home]]

El directorio /home se trata de un **directorio variable y compartible**. Este directorio está **destinado a alojar la totalidad de archivos personales de los distintos usuarios del sistema operativo a excepción del usuario root**. Algunos de los archivos personales almacenados en la carpeta /home son fotografías, documentos de ofimática, vídeos, etc.

### Directorio [[/lib]]

El directorio /lib es un **directorio estático y que puede ser compartible**. Este directorio **contiene bibliotecas compartidas que son necesarias para arrancar los ejecutables que se almacenan en los directorios /bin y /sbin**.

### Directorio [[/mnt]]

El directorio /mnt **tiene la finalidad de albergar los puntos de montaje de los distintos dispositivos de almacenamiento** como por ejemplo discos duros externos, particiones de unidades externas, etc.

### Directorio [[/media]]

La función del directorio /media es similar a la del directorio /mnt. Este directorio **contiene los puntos de montaje de los medios extraíbles de almacenamiento** como por ejemplo memorias USB, lectores de CD-ROM, unidades de disquete, etc.

### Directorio [[/opt]]

El contenido almacenado en el directorio /opt **es estático y compartible**. **La función de este directorio es almacenar programas que no vienen con nuestro sistema operativo** como por ejemplo Spotify, Google-earth, Google Chrome, Teamviewer, etc.

### Directorio [[/proc]]

El directorio /proc **se trata de un sistema de archivos virtual**. Este sistema de archivos virtual **nos proporciona información acerca de los distintos procesos y aplicaciones que se están ejecutando en nuestro sistema operativo**.

### Directorio [[/root]]

El directorio /root se trata de un **directorio variable no compartible**. El directorio /root **es el directorio /home del administrador del sistema** (usuario root).

### Directorio [[/sbin]]

El directorio /sbin se trata de un **directorio estático y compartible**. Su función es similar al directorio /bin, pero a diferencia del directorio /bin, el directorio /sbin **almacena archivos binarios/ejecutables que solo puede ejecutar el usuario root** o administrador del sistema.

### Directorio [[/srv]]

El directorio /srv se usa **para almacenar directorios y datos que usan ciertos servidores que podamos tener instalados en nuestro ordenador**.

### Directorio [[/tmp]]

El directorio /tmp es **donde se crean y se almacenan los archivos temporales y las variables para que los programas puedan funcionar de forma adecuada**.

### Directorio [[/usr]]

El directorio /usr es un **directorio compartido y estático**. Este directorio es el que **contiene la gran mayoría de programas instalados** en nuestro sistema operativo.

Todo el contenido almacenado en la carpeta /usr es accesible para todos los usuarios y **su contenido es solo de lectura**.

### Directorio [[/var]]

El directorio /var **contiene archivos de datos variables y temporales como por ejemplo los registros del sistema (logs), los registros de programas que tenemos instalados en el sistema operativo, archivos spool, etc.**

**La principal función del directorio /var es la detectar problemas y solucionarlos**. Se recomienda ubicar el directorio /var en una partición propia, y en caso de no ser posible es recomendable ubicarlo fuera de la partición raíz.

### Directorio [[/sys]]

Directorio que **contiene información similar a la del directorio /proc**. Dentro de esta carpeta podemos encontrar **i****nformación estructurada y jerárquica acerca del kernel de nuestro equipo, de nuestras particiones y sistemas de archivo, de nuestros drivers**, etc.

### Directorio [[/lost-found]]

Directorio que se crea en las particiones de disco con un sistema de archivos ext después ejecutar herramientas para restaurar y recuperar el sistema operativo como por ejemplo fsch.

Si nuestro sistema no ha presentado problemas este directorio estará completamente vacío. En el caso que hayan habido problemas **este directorio contendrá ficheros y directorios que han sido recuperados tras la caída del sistema operativo**.

## 14. Uso de bashrc y zshrc

[[ls -a]]
Detectar archivos ocultos.

`mkdir .MyDirectory/`
Creamos un directorio oculto.

`~` = /home/usuario // /home/alfonso

En esta clase consiste en enseñarnos a hacer funciones / utilidades:

1. Abrimos el archivo `nano .zshrc` en `/home/alfonso`

Para ver nuestra [[IP]]:

- [[hostname -I]]
- [[ifconfig]]
Interfaces de Red.

`hostname -I | awk '{print $1}''`
[[awk]]: me printea el primer argumento que me devuelve `hostname -I`
En este caso, nos printea la primera IP.

2. `echo "Tu IP privada es: $(hostname -I | awk '{print $1}')`

Esto lo pegamos en el archivo `.zshrc` y ponemos lo siguiente:

3. `function `[[vermiip]] `(){`
			`echo "Tu IP privada es: $(hostname -I | awk '{print $1}')`
`}`

## 15. Actualización y Upgradeo del sistema

[[apt update]]

**NO HACER NUNCA UN** `apt upgrade`

[[parrot-upgrade]]

## 16.  Uso y manejo con [[Tmux]]

`apt install Tmux`
Instalar Tmux.

`apt search tmux`
Saber si tienes instalado Tmux.

`tmux`
Iniciar tmux.

`tmux new -s Academia`
Iniciamos tmux con una sesión con el nombre de "Academia".

Para darle colorines al tmux:
1. https://github.com/gpakosz/.tmux nos metemos en este enlace
2. Seguimos las instrucciones de instalación.

> Sesiones > Ventajas > Paneles

**`control + b` = atajo**

`atajo + (sueltas) + m
Modo ratón.


`atajo + (sueltas) + shift + 4
Cambiar el nombre de la sesión.

`atajo + (sueltas) + ,`
Cambiar el nombre de la ventana.


`atajo + (sueltas) + c`
Crear una ventana nueva.

`atajo + (sueltas) + númeroDeLaVentana`
Cambiar entre ventanas.

`atajo + (sueltas) + shift + 2`
Crear un panel horizontal.

`atajo + (sueltas) + shift + 5
Crear un split vertical.

`atajo + (sueltas) + o
Moverte entre paneles. // Alternar paneles.

`atajo + (sueltas) + flechasDeMovimiento
Igual al `atajo + o` pero con las flechas.

`atajo + (sueltas) + x // exit`
Para cerrar un panel.

`atajo + (sueltas) + control + flechas de movimiento
Para cambiar el size: se puede hacer así, y con el modo del ratón.


`atajo + (sueltas) + [ (se consigue con AltGr + `)
Para entrar en modo copiar.

`control + espacio`
Empezar a aplicar una selección.

`alt + w`
Copiar lo seleccionado.

`atajo + (sueltas) + ] (se consigue con AltGr + +)
Pegar lo seleccionado.

`atajo + (sueltas) + d 
Attachear sesiones (cómo que las guardas.)

`tmux list-sessions`
(Fuera de tmux) Desplegar las sesiones que están attacheadas.

`tmux attach -t Nombre` 
`tmux attach -t Hack4u`
Sirve para abrir el tmux con esa sesión desplegada, pero si tienes solo una, puedes hacer `tmux attach` y si se te abre esa en específico.

`atajo + (sueltas) + w
Puedes moverte entre las diferentes sesiones y sus ventanas.

## 17. Búsquedas a nivel de sistema

Nosotros, cómo usarios normales (alfonso), cuándo hagamos búsquedas habrán directorios a los que no podremos entrar, por lo tanto, siempre pondremos `2>/dev/null`

[[find]] `/ -name passwd 2>/dev/null`
Búscame desde la raíz un archivo que se llame passwd, y méteme los errores en el null.

`find / -name passwd 2>/dev/null | xargs ls -l`
A los outputs que nos ha dado antes, les hacemos un `ls -l`.

`find / -perm 4000 2>/dev/null`
Buscamos dentro de la raíz, archivos según sus permisos.

`find / -group alfonso 2>/dev/null`
Nos da tantos archivos como directorios del grupo alfonso.

`find / -group alfonso -type f 2>/dev/null`
`-type f`: file
`-type d`: directory

`find / -user root -writable 2>/dev/null`
Aquellos archivos que usan de root en los que se puedan escribir.

`find / -user root -executable 2>/dev/null`
Aquellos archivos que usan de root que se pueden ejecutar.

`find / -name dex\* 2>/dev/null`
`find / -name \*dex\* 2>/dev/null`
`find / -name dex\*.sh 2>/dev/null`
Encuéntrame estos archivos cuyo nombre empiece por dex...


## 18. Creación de scripts en [[Bash]]

Son los archivos con extensión [[.sh]]

Aunque un archivo `bash` no tenga permisos de ejecución, con un `bash fileName.sh` se ejecuta.

Para ejecutar un archivo bash escribimos:
`./fileName.sh`

Abrimos el archivo y escribimos:

`#!/bin/bash`

`echo -e "\n Esta es tu dirección IP privada -> $(ip a | grep ens33 | tail -n 1 | awk '{print $2}' | awk '{print $1}' FS="/")"`

>`-e`: nos pilla los carácteres especiales, como los saltos de línea `\n`.
>`ip a`: nos da una lista de IP's.
>`grep ens33`: nos filtra en el output en la que pone ens33.
>`tail -n 1`: de todo el output, nos quedamos con la última línea.
>`awk '{print $2}'`: nos quedamos con el primer argumento (segunda palabra de la frase).
>`awk '{print $1}' FS="/")`: nos quedamos con el primer argumento, usando como limitador la barra.


## 19. Uso y configuración de la [[Kitty]] (lo haremos en el curso de personalización)

`apt install kitty`
Instalar kitty.


## 20. Uso del editor [[Vim]]

S4vitar usa Nvim

Dos modos: inserción y el normal.

`escape`
Entrar en el modo normal.

`alt + u`
Deshace.

**Alternativa a las fechas:**
**j**: moverte a la línea de abajo.
**k**: moverte a la línea de arriba.
**l**: moverte a la línea de la derecha.
**h**: moverte a la línea de la izquierda.

**i**: entrar en modo inserción.

**0** = inicio.
**$** = fin.

**w**: te sirve para moverte entre palabras.
**8 + + w**: te has movido 8 palabras.
**d + + w**: te elimina una palabra.
**3 + d + w**: te elimina 3 palabras.
**d + + d**: te elimina una línea.
**2 + d + d**: te elimina 2 líneas.

`v`
Entrar en el modo visual / selección.

`y`
Copiar lo seleccionado.

`p`
Pegas lo copiado.

`o`
Te crea una nueva línea.

**MACROS**
`q + letra`
Iniciamos la grabación.

`d w j`
Bórrame la primera palabra y salta a la siguiente línea.

`q`
Guardamos el registro.

`31@a`
Hazme el Macro "a" 31 veces.

**FILTROS**
`Escape /`
Nos ponemos en control f

**SUSTITUCIONES**
`:%s/nologin/login`
Sustituye el nologin por login.

`:%s/nologin/login/g`
Sustituye el nologin por login pero solo en la línea seleccionada.


## 21. Conexiones SSH

[[SSH]] es el nombre de un protocolo y del programa que lo implementa cuya principal función es el acceso remoto a un servidor por medio de un canal seguro en el que toda la información está cifrada.

**¿Cómo saber si el servidor está encendido?**
`ping -c 1 nombre/enlaceDeLaMáquina`

`ssh userName@virtualMachine -p Port`
`ssh bandit0@bandit.labs.overthewire.org -p 2220`
Conectarse a una máquina / servidor.
Conéctame por ssh al usuario bandit0 al servidor tal, en el puerto 2220.

Cuándo nos conectemos a un servidor, si hacemos:
`sshpass -p 'Password' ssh userName@virtualMachine -p Port
No hará falta que tengamos que introducir de nuevo la contraseña.


## 22. Lectura de archivos especiales (1-2)

Formas de abrir un archivo llamado "-". Cuándo nos encontremos con esto, no se podrá abrir, ya que al hacer el `cat`, lo tomará como que está a la espera de un parámetro:

> `cat /home/bandit1/-`
> Al haber llamado al directorio en el que nos encontramos, ahora hemos podido abrirlo sin ningún problema.

>`cat ./-`
>El "." nos sirve para indicar que queremos abrir el archivo "-" que se encuentra en el directorio actual de trabajo.

> `cat $(pwd)/-`


## 23. Lectura de archivos especiales (2-2)

Abrir un archivo cuyo nombre tiene espacios:

>`cat "spaces in this filename"`

> `cat spaces\ in\ this\ filename`

> `cat s*`
> Quiero abrir un archivo cuyo nombre empieza por s y le sigue algo.

> `cat /home/bandit2/s*`

> `cat /home/bandit2/*`
> En el caso de que haya un único archivo, para abrir todos los archivos.


## 24. Directorios y archivos ocultos

**[[Ocultar]] archivos y directorios**
`.fileName`
`.directoryName`
Hay que ponerles un "." al principio (llamados "archivos dot").

[[ls -la]]
Listar contenido oculto y con sus permisos.

`file fileName`
`file .hidden
Nos devolverá el tipo de archivo que es (magic numbers).
ASCII.

[[find .]]
Te muestra todos los archivos, ocultos y no ocultos.

`find . -type f`
Nos muestra todos los archivos que sean files, no directorys.

`find . -type f | xargs cat`


## 25. Detección del tipo y formato de archivos

Hay algunos archivos cuyo formato será en "data", pues si hacemos

`find . -type f | xargs file`
Le estamos diciendo que nos busque a todos aquellos archivos que sean files y que a su vez, nos dé el tipo de archivo que es.


## 26. Búsquedas precisas de archivos (1-2)

`find . -type f -readable ! -executable -size 1033c | xargs file`
Búscame desde aquí, todos aquellos archivos que sean files, que sean humanamente leíbles, NO ejecutables, cuyo tamaña sea de 1033 bytes, y una vez que lo encuentres, me sacas el tipo de archivo que sea.


## 27. Búsquedas precisas de archivos (2-2)

`find . -type f -user bandit7 -group bandit6 -size 33c 2>/dev/null | xargs cat`

Búscame desde dónde estoy un archivo tipo file, cuyo usuario sea bandit7, grupo bandit6, que pese 33 bytes, los errores de no abrir archivos me los quitas y después me abres el archivo.


## 28. Métodos de filtrado de datos (1-2)

`cat data.txt | grep "millionth"`
Ábreme el data.txt y fíltrame la palabra millionth.

`cat data.txt | grep "millionth" | awk 'NF{print $NF}'`
Quédate con el argumento del final.
Recordatorio: awk sirve para que me dé ciertos parámetros de un output.

`cat data.txt | grep "millionth" | awk '{print $2}''`
Quédate con el segundo argumento.

[[tr]]
Aplica sustituciones.

[[sed]]
Sed es mejor que tr a la hora de cambiar palabras.

`echo "Hola esto es una prueba prueba" | sed 's/prueba/probando/g'`
Me cambia los prueba por probando. 
En el caso de tener más de una palabra para cambiar, si le ponemos esa `g` al final, lo sustituiremos en todas.


## 29. Métodos de filtrado de datos (2-2)

Tenemos muchas líneas iguales, y queremos una que sea única:

`cat data.txt | `[[sort]] `data.txt | `[[uniq]] `-u`
Abre el data.txt, nos coge todas las líneas iguales y nos devuelve la que esté sola.

## 30. Interpretación de archivos binarios

El comando **strings** de Linux permite ver los caracteres legibles para humanos dentro de cualquier archivo.

[[strings]] `data.txt`

## 31. Codificación y decodificación en base64

El algoritmo de codificación Base64 no es un algoritmo de cifrado, se decodifica fácilmente y, por lo tanto, no debe utilizarse como un método de cifrado seguro. No recomiendo que utilicéis esta técnica para proteger datos confidenciales, ya que se puede tensar en cuestión de segundos. En tal caso, es recomendable emplear métodos de cifrado seguros.

`echo "Hola esto es una prueba" |` [[base64]]
Pasar un texto a base64.

`echo "Hola esto es una prueba" | base64 -w 0`
Cuándo queremos que al pasar un texto a base64, que tenga múltiples líneas, nos lo meta todo en una misma línea.

`echo "texto en base64" | base64 -d`
Nos lo decodea y nos lo pasa de base64 a texto legible.

## 32. Cifrado césar y uso de tr para la traducción de caracteres

Si sabemos que las letras de un archivo han sdo rotadas X posiciones, podemos buscar:

>https://rotX.com

Y nos mete una página en la que, metiendo este texto rotado, nos pone el texto sin rotar (el anterior).

Opción de sustitución (sabiendo que nos vamos a mover 13 posiciones):

`cat data.txt | tr '[G-ZA-Fg-za-f]' '[T-ZA-S-t-za-s]'`
Nos movemos desde la G, hasta la F, y después se repite pero en minúscula. 

Manera más fácil (sabiendo que nos vamos a mover 13 posiciones)
`cat data.txt | tr '[A-Za-z]' '[N-ZA-Mn-za-m]'`

## 33. Creamos un descompresor recursivo automático de archivos en Bash

[[xxd]]
Ver en hexadecimal los datos.

`xxd -ps`
Quitar lo que no nos interesa, lo de los datos. Lo importante es lo del centro.

`xargs`
Juntarlo todo en una sola línea.

`tr -d ' '`
Quítame los espacios.

`echo "Hola esto es una prueba" | tee prueba`
Te crea un archivo llamado prueba, con el output del echo.


**Descomprimir de manera lenta archivos comprimidos:**

Si tenemos un archivo en hexadecimal, habrá que pasarlo a normal:

`cat data | xxd -r`
`-r` nos hace la reversa.

[[7z]] `x data.gz`
`7z` nos descomprime todo tipo de archivos, ya estén comprimidos de X o Y forma, y con `x` podemos descomprimir todo tipo de archivos.

`7z l data`
Ver lo que hay dentro del archivo comprimido.


**Como esto es muy lento, vamos a hacer un scrypt**.


## 34. Manejo de pares de claves y conexiones SSH

Los pares de claves [[SSH]] son dos claves criptográficamente seguras que pueden usarse para autenticar a un cliente a un servidor SSH. Cada par de claves está compuesto por una **clave pública** y una **clave privada**. 

El **cliente** mantiene la **clave privada** y debe mantenerla en absoluto secreto. Poner en riesgo la clave privada puede permitir a un atacante no autorizado iniciar sesión en los servidores que están configurados con la clave pública asociada sin autenticación adicional. Como medida de precaución adicional, es recomendable cifrar la clave en el disco con una frase de contraseña.

La **clave pública** asociada puede compartirse libremente sin ninguna consecuencia negativa. La clave pública puede usarse para cifrar mensajes que **sólo la clave privada puede descifrar**. Esta propiedad se emplea como forma de autenticación mediante el uso del par de claves.



Debería haber un directorio oculto llamado `.ssh` en tu carpeta personal como usuario. 

En el caso de que no venga instalado el `openssh`, es mejor instarlo con `apt install openssh` o `apt install ssh`.

Una vez instalado, vamos a tener que habilitar el servicio:
`sudo systemctl start sshd` (de demon, el diablo del ssh).

`sudo systemctl stop sshd`
Para pararlo.

`ssh-keygen`
Nos sirve para creanos el par de claves: una pública y una privada.

Y tenemos el `id_rsa` y el `id_rsa.pub` (el público).

Para acceder a un sistema sin proporcionar contraseña, podemos jugar con la clave pública:
`cp id_rsa.pub authorized_keys`
**EL NOMBRE DE LA COPIA TIENE QUE SER ESTE SÍ O SÍ PARA QUE FUNCIONE**

Para yo meterme ahora, por ejemplo, desde mi equipo a otro sistema, tengo que generarme mis dos claves, y la pública incorporarla en el directorio personal del usuario al que quiero acceder (en el /.ssh):
En el `/home/usuario/.ssh`.

En el `authorized keys` (del equipo al que queremos acceder) meter la clave pública de nuestro equipo (nuestra clave pública en su authorized keys).


**OTRA FORMA**
Primero borrar el `authorized keys` y hacer que la clave `id_rsa` hacerla autorizada para que cualquiera que entre con esta clave pueda entrar (como hacemos en el overthewire.org).

Ese `ssh` tiene un comando alternativa que es `ssh-copy-id`:

`ssh-copy-id -i id_rsa myUser@localhost`
Convertir la clave privada en la clave autorizada.

Esto es para yo meterme en la suya. Si quiero que otras personas se conecten a la mía, les tengo que pasar mi clave privada, y ellos hacen lo del `ssh -i id_rsa userAlQueQuieroConectarme@esto`



`ssh -i sshkey.private bandit14@localhost`
Tenemos la clave privada, le decimos que tenemos la clave privada, y que nos queremos meter como bandit14 en esta máquina virtual (ESTAMOS ESCALANDO PERMISOS).


## 35. Uso de [[netcat]] para realizar conexiones

En total: 65535 puertos.

`nc localhost 30000`
Conéctame al puerto 30000 con `netcap`.

`netstat -nat`
`ss -nltp`
`cat /proc/net/tcp`
Ver los puertos que están abiertos.

`lsof -i:port`
`lsof -i:22`
Dime qué servicio está corriendo por el puerto 22.

## 36. Uso de conexiones encriptadas

**Ncat** puede encriptar el tráfico usando [[SSL]]. En el modo de conexión, basta con añadir la opción ‘**–ssl**‘.

[[ncat]]
Es cómo `netcap`, pero tiene el parámetro `ssl`:

`ncat --ssl 127.0.0.1 30001`
Conéctame con `ncat` al localhost al puerto 30001 a través de `ssl`.

## 37. Creando nuestros propios escáneres en Bash

Si tenemos un puerto abierto:

`echo ' ' > /dev/tcp/127.0.0.1/22 && echo "El puerto está abierto"`
Vamos a enviar un espacio en blanco a ese puerto con su localhost. Si nos devuelve: El puerto está abierto... Es que efectivamente, está abierto.


Si sabemos que tenemos un puerto abierto, en un intervalo de 1000 puertos, no vamos a estar mirando uno a uno todos los puertos. Vamos a crear un scrypt:

(Mirar el de PortScan)


**Alternativa**
**Usar [[Cómo usar Nmap]]**
`nmap --open -T5 -v -n -p31000-32000 127.0.0.1`
Búscame los puertos que estén abiertos, hazlo una velocidad de locos (0-5), lístame los resultados cuándo los encuentres (aparte del output final), quítame los puertos DNS, desde el puerto 31000 hasta el 32000.


## 38. Detección de diferencias entre archivos

[[wc]]
`wc -l *`
Ver cuántas líneas tiene un archivo.

`diff passwords.old passwords.new`
Entre estos dos archivos, dime qué diferencia hay.


## 39. Ejecución de comandos por SSH

A través del archivo de configuración ‘**.bashrc**‘ o ‘**.zshrc**‘, es posible definir una serie de acciones a llevar a cabo a la hora de obtener una consola interactiva, en este caso tras ingresar por SSH.

Es por ello que tras ingresar, somos expulsados de forma inmediata, dado que así ha sido definido en el archivo de configuración ‘**.bashrc**‘ para el caso que estamos tratando. Si colamos un comando al final de nuestra línea al aplicar una autenticación por SSH, lograremos que ese comando sea introducido a nivel de sistema antes de que se interprete el archivo de configuración pertinente.



Si tenemos algo configurado en el `.bashrc` que nos está echando cada vez que nos intentamos meter en un usuario, podemos meter un comando como `bash` para que nos abra una `bash` en la que poder escribir antes de que se ejecute el `.bashrc` para que nos eche.


## 40. Abusando de privilegio [[SUID]] para migrar de usuario

**SUID** es un permiso de archivo especial para archivos ejecutables que permite a otros usuarios ejecutar el archivo con los permisos efectivos del propietario del archivo. [[**SGID**]], por el contrario, es un permiso de archivo especial que también se aplica a los archivos ejecutables y permite a otros usuarios heredar el GID efectivo del propietario del grupo de archivos.

**SUID** significa “**establecer ID de usuario**” (**Set owner User ID**) y **SGID** significa “**establecer ID de grupo**” (**Set Group ID up on execution**).



Si tenemos un binario `suid` podemos correr comandos después de ejecutar el comando:

`./binaryName command`
`./bandit-do whoami`
`./bandit-do sh`
Nos abre una terminal en la que podemos escribir.


## 41. Jugando con conexiones

El bandit20 nos dice que hay que hacer conexión con el puerto que queramos (S4vitar lo hace con el 4646), y que tenemos que introducir la contraseña del bandit20 para que nos devuelva la contraseña del bandit21.

Para abrir un puerto temporal podemos usar `netcap`:

[[nc]] `-nlvp 4646`
Ponme en modo de escucha `(-l)`, sin que me aplique la resolución DNS `(-n)`, v de verbose, `(-p)` es para el puerto 4646.

Una vez abierto este puerto de escucha, podemos abrir un archivo `SUID` y abrirlo por el puerto que queramos:

`./suidName port`
`./suconnect 4646`

## 42. Abusando de tareas Cron (1-3)

[[Cron]] es un administrador de tareas de Linux que permite ejecutar comandos en un momento determinado, por ejemplo, cada minuto, día, semana o mes. Si queremos trabajar con cron, podemos hacerlo a través del comando **crontab**.

El formato de configuración de cron es el siguiente: **Minuto Hora Dia-del-Mes Mes Dia-de-la-Semana Comando-a-Ejecutar**.

## 43. Abusando de tareas Cron (2-3)

## 44. Abusando de tareas Cron (3-3)

## 45. Comprendiendo las extensiones de las tareas Cron

**AVISO**: OverTheWire ha estado realizando una serie de cambios, comunicaros que ahora en vez de la ruta ‘**/var/spool/bandit24/**‘ tenéis que emplear la ruta ‘**/var/spool/bandit24/foo**‘, por lo demás, todo sigue igual.

Y con esta clase ¡concluimos las tareas Cron!

Esta parte deciros que es fundamental, sobre todo de cara a los módulos de Hacking que vamos a estar tocando en la academia, pues en muchas de las ocasiones veremos cómo nos será necesario no sólo identificar qué tareas se ejecutan en el sistema a intervalos regulares de tiempo, sino también saber cómo poder abusar de estas para elevar nuestros privilegios.

¡Pero lo bueno se hace esperar!, lo primero es lo primero, tenemos que cimentar las bases y no construir la casa por el tejado.

## 47. Comprendiendo las expresiones de las tareas Cron

`*/x == Cada x algo`

